from datetime import datetime
from venv import logger
from flask import Blueprint, json, render_template, request, jsonify, session
from sqlalchemy import and_, desc, func
from werkzeug.security import check_password_hash
from app.utils.database import db
from app.models.question import Question
from app.models.course import Course
from app.models.user import User
from app.models.courseclass import Courseclass
from app.services.lesson_plan import generate_ai_analysis, generate_post_class_questions, generate_pre_class_questions
from app.models.studentanswer import StudentAnswer
from app.models.teaching_design import TeachingDesign
from app.models.teachingdesignversion import TeachingDesignVersion
from app.models.MindMapNode import MindMapNode
question_bp=Blueprint('question',__name__)

def is_logged_in():
    return 'user_id' in session
# 获取当前登录的用户
def get_current_user():
    user_id = session.get('user_id')
    if user_id:
        return User.query.get(user_id)
    return None

#生成课前预习题目
@question_bp.route('/createprequestion/<int:course_id>', methods=['POST'])
def teachingdesign_create(course_id):
    # 检查用户是否登录
    if not is_logged_in():
        logger.warning("Unauthorized access attempt")
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前用户
        current_user = get_current_user()
        if not current_user:
            logger.error("Current user not found")
            return jsonify({'error': 'User not found'}), 404

        # 获取请求数据
        data = request.json
        if not data:
            logger.error("No data provided in request")
            return jsonify({'error': 'No data provided'}), 400

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            logger.error(f"Course with ID {course_id} not found")
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            logger.error(f"Course class for course ID {course_id} not found")
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            logger.warning(f"User {current_user.id} does not have permission to create questions for course ID {course_id}")
            return jsonify({'error': 'You do not have permission to create questions for this course'}), 403

        # 获取课程描述和请求内容
        course_description = course.description if course.description else ""
        user_content = data.get('content', '')
        
        # 组合内容用于AI生成题目
        combined_content = f"课程描述: {course_description}\n\n教师补充内容: {user_content}" if course_description else user_content

        # 调用AI接口获取题目集合
        ai_questions = generate_pre_class_questions(combined_content)
        if not ai_questions:
            logger.error("No questions generated by AI")
            return jsonify({'error': 'Failed to generate questions'}), 500

        # 批量创建题目
        created_question_ids = []
        for ai_question in ai_questions:
            # 创建新的问题记录
            new_question = Question(
                course_id=course_id,
                type=ai_question['type'],
                content=ai_question['content'],
                correct_answer=ai_question['correct_answer'],
                difficulty=ai_question['difficulty'],
                timing='pre_class'
            )
            db.session.add(new_question)
            db.session.flush()  # 确保生成ID
            created_question_ids.append(new_question.id)

        # 提交事务
        db.session.commit()
        logger.info(f"Successfully created {len(created_question_ids)} questions for course ID {course_id}")

        # 返回成功响应
        return jsonify({
            'message': 'Questions created successfully',
            'question_ids': created_question_ids
        }), 201

    except Exception as e:
        # 捕获异常并回滚事务
        db.session.rollback()
        logger.error(f"Error creating questions: {str(e)}")
        return jsonify({'error': str(e)}), 500
    

#删除单个题目
@question_bp.route('/deletequestion/<int:question_id>', methods=['DELETE'])
def delete_question(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要删除的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to delete this question'}), 403

        # 删除题目记录
        db.session.delete(question)
        db.session.commit()

        return jsonify({
            'message': 'Question deleted successfully',
            'question_id': question_id
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    

# 查询单个课程的所有预习题目
@question_bp.route('/prequestions/<int:course_id>', methods=['GET'])
def get_questions_by_course(course_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, timing='pre_class', is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id, timing='pre_class').all()

        # 返回题目列表
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public  # 返回 is_public 字段
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    

@question_bp.route('/question/<int:question_id>', methods=['GET'])
def get_question(question_id):
    """
    查询单个题目，如果是课后题目则返回知识点信息
    """
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to view this question'}), 403

        # 准备返回数据
        question_data = {
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public  # 添加 is_public 字段
        }

        # 如果是课后题目，添加知识点信息
        if question.timing == 'post_class':
            question_data['knowledge_point_id'] = question.knowledge_point_id
            if question.knowledge_point:
                question_data['knowledge_point_name'] = question.knowledge_point.node_name
                question_data['knowledge_point_content'] = question.knowledge_point.node_content
            else:
                question_data['knowledge_point_name'] = None
                question_data['knowledge_point_content'] = None

        return jsonify(question_data), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    

# 修改单个题目
@question_bp.route('/question/<int:question_id>', methods=['PUT'])
def update_question(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要修改的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to update this question'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 更新题目信息
        question.type = data.get('type', question.type)
        question.content = data.get('content', question.content)
        question.correct_answer = data.get('correct_answer', question.correct_answer)
        question.difficulty = data.get('difficulty', question.difficulty)
        question.timing = data.get('timing', question.timing)
        question.is_public = data.get('is_public', question.is_public)  # 添加对 is_public 字段的更新

        # 提交更改
        db.session.commit()

        return jsonify({
            'message': 'Question updated successfully',
            'question_id': question.id,
            'updated_fields': {
                'type': question.type,
                'content': question.content,
                'correct_answer': question.correct_answer,
                'difficulty': question.difficulty,
                'timing': question.timing,
                'is_public': question.is_public  # 返回更新后的 is_public 状态
            }
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    
# 修改题目的公开状态
@question_bp.route('/question/<int:question_id>/toggle_public', methods=['PUT'])
def toggle_question_public(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要修改的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to update this question'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 获取公开状态的值
        is_public = data.get('is_public')
        if is_public is None:
            return jsonify({'error': 'No is_public value provided'}), 400

        # 更新题目的公开状态
        question.is_public = is_public

        # 提交更改
        db.session.commit()

        return jsonify({
            'message': 'Question public status updated successfully',
            'question_id': question.id,
            'is_public': question.is_public
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

# 根据单个教学设计版本生成课后习题
@question_bp.route('/design/<int:design_id>/version/<int:version_id>/generate_post_class_questions', methods=['POST'])
def generate_post_class_questions_for_version(design_id, version_id):
    """
    根据单个教学设计版本生成课后习题
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify(code=401, message="请先登录"), 401

        # 2. 查询教学设计和版本
        design = TeachingDesign.query.get(design_id)
        if not design:
            return jsonify(code=404, message="教学设计不存在"), 404

        version = TeachingDesignVersion.query.get(version_id)
        if not version or version.design_id != design.id:
            return jsonify(code=404, message="教学设计版本不存在"), 404

        # 3. 权限验证（教师只能生成自己创建的版本的课后习题）
        if current_user.role == 'teacher' and version.author_id != current_user.id:
            return jsonify(code=403, message="无操作权限"), 403

        # 4. 获取教学设计版本的内容
        version_content = json.loads(version.content) if version.content else {}
        lesson_plan_content = version_content.get('plan_content', '')

        # 5. 获取思维导图数据（假设存储在 teaching_design 的 mindmap 字段中）
        mind_map = json.loads(design.mindmap) if design.mindmap else {}

        # 6. 调用 AI 接口生成课后习题
        questions = generate_post_class_questions(lesson_plan_content, mind_map)

        # 7. 将生成的课后习题存储到数据库
        for question_data in questions:
            new_question = Question(
                course_id=design.course_id,
                type=question_data['type'],
                content=question_data['content'],
                correct_answer=question_data['correct_answer'],
                difficulty=question_data['difficulty'],
                timing='post_class',
                is_public=False,
                knowledge_point_id=question_data.get('knowledge_point_id')  # 知识点 ID 字段
            )
            db.session.add(new_question)

        db.session.commit()

        # 8. 返回响应
        return jsonify(code=200, message="课后习题生成成功", data=questions), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"生成课后习题失败: {str(e)}")
        return jsonify(code=500, message="服务器内部错误"), 500


#根据单个课程查询所有课后习题功能
@question_bp.route('/postquestions/<int:course_id>', methods=['GET'])
def get_post_class_questions_by_course(course_id):
    """
    查询单个课程的所有课后习题，并返回知识点信息
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        # 2. 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 3. 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 4. 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 5. 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, timing='post_class', is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id, timing='post_class').all()

        # 6. 返回题目列表，包含知识点信息
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public,
            'knowledge_point_id': question.knowledge_point_id,
            'knowledge_point_name': question.knowledge_point.node_name if question.knowledge_point else None,
            'knowledge_point_content': question.knowledge_point.node_content if question.knowledge_point else None
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    



#根据单个课程查询所有题目功能
@question_bp.route('/allquestions/<int:course_id>', methods=['GET'])
def get_all_questions_by_course(course_id):
    """
    查询单个课程的所有题目（包括课前预习题目和课后习题）
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        # 2. 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 3. 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 4. 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 5. 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id).all()

        # 6. 返回题目列表
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    

@question_bp.route('/course/<int:course_id>/heatmap_data', methods=['GET'])
def get_course_heatmap_data(course_id):
    """
    获取课程课后习题难度热力图数据
    Parameters:
        course_id (int): 课程ID
    Returns:
        {
            "heatmap_data": [
                {"x": 1, "y": 3, "value": 0.65, "original_id": 101},
                {"x": 2, "y": 2, "value": 0.89, "original_id": 102},
                ...
            ],
            "course_name": "Python基础"
        }
    """
    try:
        # 验证用户权限
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 只允许课程教师访问分析数据
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class or current_user not in course_class.teachers:
            return jsonify({'error': 'Forbidden'}), 403

        # 查询课后习题数据（按题目ID排序）
        raw_data = (
            db.session.query(
                Question.id.label('original_id'),
                Question.difficulty,
                func.avg(StudentAnswer.correct_percentage / 100.0).label('avg_correct')
            )
            .join(StudentAnswer, Question.id == StudentAnswer.question_id)
            .filter(
                Question.course_id == course_id,
                Question.timing == 'post_class'
            )
            .group_by(Question.id)
            .order_by(Question.id)
            .all()
        )

        # 转换为热力图格式（X轴为顺序编号）
        heatmap_data = [
            {
                "x": idx + 1,
                "y": item.difficulty,
                "value": round(item.avg_correct, 2),
                "original_id": item.original_id
            }
            for idx, item in enumerate(raw_data)
        ]

        return jsonify({
            "heatmap_data": heatmap_data,
            "course_name": course.name
        }), 200

    except Exception as e:
        logger.error(f"Error generating heatmap data: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
@question_bp.route('/course/<int:course_id>/error_ranking', methods=['GET'])
def get_course_error_ranking(course_id):
    """
    获取课程高频错误题目排行榜
    Parameters:
        course_id (int): 课程ID
        top_n (int, optional): 返回的题目数量，默认为10
    Returns:
        {
            "ranking": [
                {
                    "rank": 1,
                    "question_id": 101,
                    "content": "HTTP状态码500表示什么？",
                    "error_rate": 0.65,
                    "common_errors": ["权限不足", "页面未找到"]
                },
                ...
            ],
            "threshold": 0.5  # 错误率警戒线
        }
    """
    try:
        # 验证用户权限（同上接口，略）
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class or current_user not in course_class.teachers:
            return jsonify({'error': 'Forbidden'}), 403

        # 获取参数
        top_n = request.args.get('top_n', default=10, type=int)

        # 1. 计算题目错误率（错误率 = 1 - 平均正确率）
        error_rates = (
            db.session.query(
                Question.id,
                Question.content,
                (1 - func.avg(StudentAnswer.correct_percentage / 100.0)).label('error_rate')
            )
            .join(StudentAnswer, Question.id == StudentAnswer.question_id)
            .filter(
                Question.course_id == course_id,
                Question.timing == 'post_class'
            )
            .group_by(Question.id)
            .order_by(desc('error_rate'))
            .limit(top_n)
            .all()
        )

        # 2. 获取每个题目的常见错误答案
        ranking_data = []
        for rank, (q_id, content, error_rate) in enumerate(error_rates, start=1):
            common_errors = (
                db.session.query(StudentAnswer.answer)
                .filter(
                    StudentAnswer.question_id == q_id,
                    StudentAnswer.correct_percentage < 100
                )
                .group_by(StudentAnswer.answer)
                .order_by(func.count().desc())
                .limit(3)
                .all()
            )
            
            ranking_data.append({
                "rank": rank,
                "question_id": q_id,
                "content": content[:50] + "..." if len(content) > 50 else content,  # 截断长内容
                "error_rate": round(error_rate, 2),
                "common_errors": [err[0] for err in common_errors]
            })

        return jsonify({
            "ranking": ranking_data,
            "threshold": 0.5  # 前端可用此值标红高错误率题目
        }), 200

    except Exception as e:
        logger.error(f"Error generating error ranking: {str(e)}")
        return jsonify({'error': str(e)}), 500

#创建新题目
@question_bp.route('/createquestion/<int:course_id>', methods=['POST'])
def create_question(course_id):
    """
    教师手动创建题目
    """
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to create questions for this course'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 提取题目信息
        question_type = data.get('type')
        content = data.get('content')
        correct_answer = data.get('correct_answer')
        difficulty = data.get('difficulty', 1)
        timing = data.get('timing', 'pre_class')
        is_public = data.get('is_public', False)

        if not question_type or not content or not correct_answer:
            return jsonify({'error': 'Missing required fields'}), 400

        # 创建新的题目记录
        new_question = Question(
            course_id=course_id,
            type=question_type,
            content=content,
            correct_answer=correct_answer,
            difficulty=difficulty,
            timing=timing,
            is_public=is_public
        )
        db.session.add(new_question)
        db.session.commit()

        return jsonify({
            'message': 'Question created successfully',
            'question_id': new_question.id
        }), 201

    except Exception as e:
        db.session.rollback()
        logger.error(f"Error creating question: {str(e)}")
        return jsonify({'error': str(e)}), 500


#创建新的课后题目
@question_bp.route('/createpostquestion/<int:course_id>', methods=['POST'])
def create_post_question(course_id):
    """
    教师手动创建题目，并可以关联到指定的知识点
    """
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to create questions for this course'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 提取题目信息
        question_type = data.get('type')
        content = data.get('content')
        correct_answer = data.get('correct_answer')
        difficulty = data.get('difficulty', 1)
        timing = data.get('timing', 'pre_class')
        is_public = data.get('is_public', False)

        # 提取知识点信息（可选）
        knowledge_point_id = data.get('knowledge_point_id')
        knowledge_point_name = data.get('knowledge_point_name')
        knowledge_point_content = data.get('knowledge_point_content', '')  # 允许为空

        # 提取教学设计 ID 和父节点 ID（由前端提供）
        teaching_design_id = data.get('teaching_design_id')
        parent_node_id = data.get('parent_node_id')  # 知识点的父节点 ID

        if not question_type or not content or not correct_answer:
            return jsonify({'error': 'Missing required fields'}), 400

        # 创建新的题目记录
        new_question = Question(
            course_id=course_id,
            type=question_type,
            content=content,
            correct_answer=correct_answer,
            difficulty=difficulty,
            timing=timing,
            is_public=is_public
        )

        # 如果提供了知识点 ID，则关联到该知识点
        if knowledge_point_id:
            # 验证知识点是否存在
            knowledge_point = MindMapNode.query.get(knowledge_point_id)
            if not knowledge_point:
                return jsonify({'error': 'Knowledge point not found'}), 404
            new_question.knowledge_point_id = knowledge_point_id
        elif knowledge_point_name:
            # 如果未提供知识点 ID，但提供了知识点名称，则创建新的知识点
            if not teaching_design_id:
                return jsonify({'error': 'Teaching design ID is required to create a new knowledge point'}), 400

            # 验证教学设计是否存在
            teaching_design = TeachingDesign.query.get(teaching_design_id)
            if not teaching_design:
                return jsonify({'error': 'Teaching design not found'}), 404

            new_knowledge_point = MindMapNode(
                teachingdesignid=teaching_design_id,
                node_name=knowledge_point_name,
                node_content=knowledge_point_content or f"Content for {knowledge_point_name}",  # 提供默认值或允许为空
                parent_node_id=parent_node_id,  # 设置父节点 ID
                is_leaf=True  # 默认为叶子节点
            )
            db.session.add(new_knowledge_point)
            db.session.flush()  # 立即提交以获取生成的 ID

            new_question.knowledge_point_id = new_knowledge_point.id

            # 如果提供了父节点 ID，则更新父节点的 is_leaf 字段
            if parent_node_id:
                # 查询父节点
                parent_node = MindMapNode.query.get(parent_node_id)
                if parent_node:
                    # 如果父节点 previously was a leaf node, update it to non-leaf
                    if parent_node.is_leaf:
                        parent_node.is_leaf = False
                        db.session.add(parent_node)
                        db.session.commit()

                    # Update the teaching design's mindmap
                    update_teaching_design_mindmap(teaching_design_id)

        db.session.add(new_question)
        db.session.commit()

        return jsonify({
            'message': 'Question created successfully',
            'question_id': new_question.id
        }), 201

    except Exception as e:
        db.session.rollback()
        logger.error(f"Error creating question: {str(e)}")
        return jsonify({'error': str(e)}), 500

def update_teaching_design_mindmap(teaching_design_id):
    """
    更新教学设计的思维导图
    """
    try:
        # 查询教学设计
        design = TeachingDesign.query.get(teaching_design_id)
        if not design:
            return

        # 查询该教学设计的所有知识点
        top_level_nodes = MindMapNode.query.filter_by(
            teachingdesignid=teaching_design_id, 
            parent_node_id=None
        ).all()

        # 递归构建思维导图
        def build_mind_map(node):
            node_data = {
                "data": {  # 将节点信息包裹在 data 字段中
                   "id": node.id,
                   "name": node.node_name,
                   "content": node.node_content,
                   "is_leaf": node.is_leaf
                },
            "children": []
            }
            for child in node.children:
                node_data["children"].append(build_mind_map(child))
            return node_data

        # 构建完整的思维导图
        mind_map = []
        for root_node in top_level_nodes:
            mind_map.append(build_mind_map(root_node))

        # 将思维导图存储到 TeachingDesign 的 mindmap 字段
        design.mindmap = json.dumps(mind_map, ensure_ascii=False)
        db.session.commit()

    except Exception as e:
        db.session.rollback()
        logger.error(f"Error updating teaching design mindmap: {str(e)}")

#为单个题目更新知识点
@question_bp.route('/question/<int:question_id>/update_knowledge_point', methods=['PUT'])
def update_question_knowledge_point(question_id):
    """
    修改单个题目所属的知识点
    """
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要修改的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to update this question'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 提取知识点信息（可选）
        knowledge_point_id = data.get('knowledge_point_id')
        knowledge_point_name = data.get('knowledge_point_name')
        knowledge_point_content = data.get('knowledge_point_content', '')  # 允许为空
        teaching_design_id = data.get('teaching_design_id')
        parent_node_id = data.get('parent_node_id')  # 知识点的父节点 ID

        # 如果提供了知识点 ID，则关联到该知识点
        if knowledge_point_id:
            # 验证知识点是否存在
            knowledge_point = MindMapNode.query.get(knowledge_point_id)
            if not knowledge_point:
                return jsonify({'error': 'Knowledge point not found'}), 404
            question.knowledge_point_id = knowledge_point_id
        elif knowledge_point_name:
            # 如果未提供知识点 ID，但提供了知识点名称，则创建新的知识点
            if not teaching_design_id:
                return jsonify({'error': 'Teaching design ID is required to create a new knowledge point'}), 400

            # 验证教学设计是否存在
            teaching_design = TeachingDesign.query.get(teaching_design_id)
            if not teaching_design:
                return jsonify({'error': 'Teaching design not found'}), 404

            new_knowledge_point = MindMapNode(
                teachingdesignid=teaching_design_id,
                node_name=knowledge_point_name,
                node_content=knowledge_point_content or f"Content for {knowledge_point_name}",  # 提供默认值或允许为空
                parent_node_id=parent_node_id,  # 设置父节点 ID
                is_leaf=True  # 默认为叶子节点
            )
            db.session.add(new_knowledge_point)
            db.session.flush()  # 立即提交以获取生成的 ID

            question.knowledge_point_id = new_knowledge_point.id

            # 如果提供了父节点 ID，则更新父节点的 is_leaf 字段
            if parent_node_id:
                # 查询父节点
                parent_node = MindMapNode.query.get(parent_node_id)
                if parent_node:
                    # 如果父节点 previously was a leaf node, update it to non-leaf
                    if parent_node.is_leaf:
                        parent_node.is_leaf = False
                        db.session.add(parent_node)
                        db.session.commit()

                    # Update the teaching design's mindmap
                    update_teaching_design_mindmap(teaching_design_id)

        # 提交更改
        db.session.commit()

        return jsonify({
            'message': 'Question knowledge point updated successfully',
            'question_id': question.id,
            'knowledge_point_id': question.knowledge_point_id
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@question_bp.route('/question-page')
def questiontest():
    return render_template('question.html')