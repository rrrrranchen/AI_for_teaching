from venv import logger
from flask import Blueprint, json, render_template, request, jsonify, session
from sqlalchemy import and_
from werkzeug.security import check_password_hash
from app.utils.database import db
from app.models.question import Question
from app.models.course import Course
from app.models.user import User
from app.models.courseclass import Courseclass
from app.services.lesson_plan import generate_post_class_questions, generate_pre_class_questions
from app.models.studentanswer import StudentAnswer
from app.models.teaching_design import TeachingDesign
from app.models.teachingdesignversion import TeachingDesignVersion
question_bp=Blueprint('question',__name__)

def is_logged_in():
    return 'user_id' in session
# 获取当前登录的用户
def get_current_user():
    user_id = session.get('user_id')
    if user_id:
        return User.query.get(user_id)
    return None

#生成课前预习题目
@question_bp.route('/createprequestion/<int:course_id>', methods=['POST'])
def teachingdesign_create(course_id):
    # 检查用户是否登录
    if not is_logged_in():
        logger.warning("Unauthorized access attempt")
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前用户
        current_user = get_current_user()
        if not current_user:
            logger.error("Current user not found")
            return jsonify({'error': 'User not found'}), 404

        # 获取请求数据
        data = request.json
        if not data:
            logger.error("No data provided in request")
            return jsonify({'error': 'No data provided'}), 400

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            logger.error(f"Course with ID {course_id} not found")
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            logger.error(f"Course class for course ID {course_id} not found")
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            logger.warning(f"User {current_user.id} does not have permission to create questions for course ID {course_id}")
            return jsonify({'error': 'You do not have permission to create questions for this course'}), 403

        # 获取课程描述和请求内容
        course_description = course.description if course.description else ""
        user_content = data.get('content', '')
        
        # 组合内容用于AI生成题目
        combined_content = f"课程描述: {course_description}\n\n教师补充内容: {user_content}" if course_description else user_content

        # 调用AI接口获取题目集合
        ai_questions = generate_pre_class_questions(combined_content)
        if not ai_questions:
            logger.error("No questions generated by AI")
            return jsonify({'error': 'Failed to generate questions'}), 500

        # 批量创建题目
        created_question_ids = []
        for ai_question in ai_questions:
            # 创建新的问题记录
            new_question = Question(
                course_id=course_id,
                type=ai_question['type'],
                content=ai_question['content'],
                correct_answer=ai_question['correct_answer'],
                difficulty=ai_question['difficulty'],
                timing='pre_class'
            )
            db.session.add(new_question)
            db.session.flush()  # 确保生成ID
            created_question_ids.append(new_question.id)

        # 提交事务
        db.session.commit()
        logger.info(f"Successfully created {len(created_question_ids)} questions for course ID {course_id}")

        # 返回成功响应
        return jsonify({
            'message': 'Questions created successfully',
            'question_ids': created_question_ids
        }), 201

    except Exception as e:
        # 捕获异常并回滚事务
        db.session.rollback()
        logger.error(f"Error creating questions: {str(e)}")
        return jsonify({'error': str(e)}), 500
    

#删除单个题目
@question_bp.route('/deletequestion/<int:question_id>', methods=['DELETE'])
def delete_question(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要删除的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to delete this question'}), 403

        # 删除题目记录
        db.session.delete(question)
        db.session.commit()

        return jsonify({
            'message': 'Question deleted successfully',
            'question_id': question_id
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    

# 查询单个课程的所有预习题目
@question_bp.route('/prequestions/<int:course_id>', methods=['GET'])
def get_questions_by_course(course_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, timing='pre_class', is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id, timing='pre_class').all()

        # 返回题目列表
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public  # 返回 is_public 字段
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    

# 查询单个题目
@question_bp.route('/question/<int:question_id>', methods=['GET'])
def get_question(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to view this question'}), 403

        # 返回题目详情
        return jsonify({
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public  # 添加 is_public 字段
        }), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    

# 修改单个题目
@question_bp.route('/question/<int:question_id>', methods=['PUT'])
def update_question(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要修改的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to update this question'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 更新题目信息
        question.type = data.get('type', question.type)
        question.content = data.get('content', question.content)
        question.correct_answer = data.get('correct_answer', question.correct_answer)
        question.difficulty = data.get('difficulty', question.difficulty)
        question.timing = data.get('timing', question.timing)
        question.is_public = data.get('is_public', question.is_public)  # 添加对 is_public 字段的更新

        # 提交更改
        db.session.commit()

        return jsonify({
            'message': 'Question updated successfully',
            'question_id': question.id,
            'updated_fields': {
                'type': question.type,
                'content': question.content,
                'correct_answer': question.correct_answer,
                'difficulty': question.difficulty,
                'timing': question.timing,
                'is_public': question.is_public  # 返回更新后的 is_public 状态
            }
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    
# 修改题目的公开状态
@question_bp.route('/question/<int:question_id>/toggle_public', methods=['PUT'])
def toggle_question_public(question_id):
    if not is_logged_in():
        return jsonify({'error': 'Unauthorized'}), 401

    try:
        # 获取当前登录用户
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'User not found'}), 404

        # 查询要修改的题目
        question = Question.query.get(question_id)
        if not question:
            return jsonify({'error': 'Question not found'}), 404

        # 获取题目所属的课程
        course = Course.query.get(question.course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 检查当前用户是否是课程班的老师
        if current_user not in course_class.teachers:
            return jsonify({'error': 'You do not have permission to update this question'}), 403

        # 获取请求中的 JSON 数据
        data = request.json
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        # 获取公开状态的值
        is_public = data.get('is_public')
        if is_public is None:
            return jsonify({'error': 'No is_public value provided'}), 400

        # 更新题目的公开状态
        question.is_public = is_public

        # 提交更改
        db.session.commit()

        return jsonify({
            'message': 'Question public status updated successfully',
            'question_id': question.id,
            'is_public': question.is_public
        }), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

#根据单个教学设计版本生成课后习题
@question_bp.route('/design/<int:design_id>/version/<int:version_id>/generate_post_class_questions', methods=['POST'])
def generate_post_class_questions_for_version(design_id, version_id):
    """
    根据单个教学设计版本生成课后习题
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify(code=401, message="请先登录"), 401

        # 2. 查询教学设计和版本
        design = TeachingDesign.query.get(design_id)
        if not design:
            return jsonify(code=404, message="教学设计不存在"), 404

        version = TeachingDesignVersion.query.get(version_id)
        if not version or version.design_id != design.id:
            return jsonify(code=404, message="教学设计版本不存在"), 404

        # 3. 权限验证（教师只能生成自己创建的版本的课后习题）
        if current_user.role == 'teacher' and version.author_id != current_user.id:
            return jsonify(code=403, message="无操作权限"), 403

        # 4. 获取教学设计版本的内容
        version_content = json.loads(version.content) if version.content else {}
        lesson_plan_content = version_content.get('plan_content', '')

        # 5. 调用 AI 接口生成课后习题
        questions = generate_post_class_questions(lesson_plan_content)

        # 6. 将生成的课后习题存储到数据库
        for question_data in questions:
            new_question = Question(
                course_id=design.course_id,
                type=question_data['type'],
                content=question_data['content'],
                correct_answer=question_data['correct_answer'],
                difficulty=question_data['difficulty'],
                timing='post_class',
                is_public=False
            )
            db.session.add(new_question)

        db.session.commit()

        # 7. 返回响应
        return jsonify(code=200, message="课后习题生成成功", data=questions), 200

    except Exception as e:
        db.session.rollback()
        logger.error(f"生成课后习题失败: {str(e)}")
        return jsonify(code=500, message="服务器内部错误"), 500


#根据单个课程查询所有课后习题功能
@question_bp.route('/postquestions/<int:course_id>', methods=['GET'])
def get_post_class_questions_by_course(course_id):
    """
    查询单个课程的所有课后习题
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        # 2. 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 3. 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 4. 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 5. 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, timing='post_class', is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id, timing='post_class').all()

        # 6. 返回题目列表
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
    



#根据单个课程查询所有题目功能
@question_bp.route('/allquestions/<int:course_id>', methods=['GET'])
def get_all_questions_by_course(course_id):
    """
    查询单个课程的所有题目（包括课前预习题目和课后习题）
    """
    try:
        # 1. 基础验证
        current_user = get_current_user()
        if not current_user:
            return jsonify({'error': 'Unauthorized'}), 401

        # 2. 验证课程是否存在
        course = Course.query.get(course_id)
        if not course:
            return jsonify({'error': 'Course not found'}), 404

        # 3. 获取课程所属的课程班
        course_class = Courseclass.query.filter(Courseclass.courses.contains(course)).first()
        if not course_class:
            return jsonify({'error': 'Course class not found'}), 404

        # 4. 检查当前用户是否是课程班的老师或学生
        if current_user not in course_class.teachers and current_user not in course_class.students:
            return jsonify({'error': 'You do not have permission to access questions for this course'}), 403

        # 5. 根据用户角色决定是否过滤 is_public 字段
        if current_user.role == 'student':
            # 学生只能查看公开的题目
            questions = Question.query.filter_by(course_id=course_id, is_public=True).all()
        else:
            # 老师可以查看所有题目
            questions = Question.query.filter_by(course_id=course_id).all()

        # 6. 返回题目列表
        return jsonify([{
            'id': question.id,
            'course_id': question.course_id,
            'type': question.type,
            'content': question.content,
            'correct_answer': question.correct_answer,
            'difficulty': question.difficulty,
            'timing': question.timing,
            'is_public': question.is_public
        } for question in questions]), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
@question_bp.route('/question-page')
def questiontest():
    return render_template('question.html')