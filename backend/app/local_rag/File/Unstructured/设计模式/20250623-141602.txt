# 结构型设计模式

## Structural Patterns

# 结构型模式分类

* 适配器模式 (Adapter)
* 桥接模式 (Bridge)
* 组合模式 (Composite)
* 装饰器模式 (Decorator)
* 外观模式 (Facade)
* 享元模式 (Flyweight)
* 代理模式 (Proxy)

# 模式7: 适配器模式 (一)

* **别名:** 包装器 (Wrapper)
* **意图:**
  * 将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以协同工作。
* **动机:**
  * 有时，一个为复用而设计的工具类因为其接口与应用程序所需的领域特定接口不匹配而无法被复用。

# 适配器模式 (二)

## 适用性

在以下情况使用适配器模式：

* 你想使用一个已经存在的类，而它的接口不符合你的需求
* 你想创建一个可复用的类，该类可以与不相关的或不可预见的类（即那些接口不一定兼容的类）协同工作
* (仅对象适配器)你需要使用几个现有的子类，但是通过子类化每一个来适配它们的接口又不现实。对象适配器可以适配其父类的接口

# 适配器模式 (三)

## 结构

### 类适配器

Client → Target → Adaptee\
Request() → SpecificRequest()

↓ → Adapter → (protected or private)\
Request() → SpecificRequest()

### 对象适配器

Client → Target → Adaptee\
Request() → SpecificRequest()

↓ → Adapter → (adaptee)\
Request() → SpecificRequest()

# 适配器模式 (三)

## 参与者与协作

* **参与者:** Client、Target、Adaptee、Adapter

* **协作方式:**

  * 类适配器 —— 通过继承实现
  * 对象适配器 —— 通过组合实现

# 适配器模式 (四)

## 评估

* 本质上是两种重用模型

  * 类适配器: 无法适配adaptee的子类，但可以重载adaptee的行为
  * 对象适配器: 可以适配adaptee的所有子类

* 适配器需要做多少适配工作？

* 可插拔适配器

* 使用双向适配器提供透明性

* 对于类适配器，使用多重继承来实现

# 适配器模式 (五)

## 实现

* 使用C++继承机制实现类适配器

* 使用内嵌对象技术实现对象适配器

* 可插拔适配器的三种实现方案:

  * 使用抽象方法定义
  * 使用代理对象
  * 参数化技术

这三种方法的实质：如何在一个类中定义抽象操作，供客户插入？—— hook技术

# 适配器模式 (六)

## 相关模式与示例

* **相关模式:**

  * 桥接模式 (Bridge)
  * 装饰器模式 (Decorator)
  * 代理模式 (Proxy)

* **示例:** DrawingEditor

| Shape                             |
| --------------------------------- |
| BoundingBox() CreateManipulator() |

| Line                              |
| --------------------------------- |
| TextShape                         |
| BoundingBox() CreateManipulator() |

| TextView    |
| ----------- |
| GetExtent() |

return text->GetExtent()

return new TextManipulator

# 模式8: 桥接模式 (一)

* **别名:** 句柄/体 (Handle/Body)

* **意图:**
  * 将抽象部分与它的实现部分分离，使它们都可以独立地变化

* **动机:**

  * 要做到"抽象(接口)与实现分离"，最常用的办法是定义一个抽象类，然后在子类中提供实现。也就是说，用继承机制达到"抽象(接口)与实现分离"
  * 但是这种方法不够灵活，继承机制把实现与抽象部分永久地绑定起来，要想独立地修改、扩展、重用抽象(接口)与实现都非常困难

# 桥接模式 (二)

## 适用性

在以下情况使用桥接模式：

* 编译时刻无法确定抽象(接口)与实现之间的关系
* 抽象部分与实现部分都可以通过子类化而扩展
* 对一个实现的修改不影响客户(无须重新编译)
* 在C++中，对客户完全隐藏实现细节
* 因为扩展的原因，需要把一个类分成两部分(以便灵活组合)
* 在多个对象之间共享数据，但客户不需要知道

# 桥接模式 (三)

## 结构

Client

**Abstraction** → imp\
Operation → Imp→OperationImp

**Implementation** → OperationImp

Refined Abstraction\
ConcreteImplmentationA\
OperationImp\
ConcreteImplmentationB\
OperationImp

### 参与者

Client, Abstraction, RefinedAbstraction, Implementor, ConcreteImplementor

# 桥接模式 (四)

## 评估

* 抽象部分与实现部分的分离，可以在运行时刻连接起来二进制兼容性
* 提高可扩充性：抽象与实现两部分可以单独扩充
* 对客户隐藏实现细节

# 桥接模式 (五)

## 实现

* 只有一个Implementor的情况
* 如何创建正确的Implementor对象？根据客户环境，或者通过工厂模式
* 共享Implementors
  * 资源管理：引用计数技术
* 使用多重继承

# 桥接模式 (六)

## 相关模式与示例

* **相关模式:**

  * 抽象工厂模式可以用来创建和配置桥接模式
  * 与适配器模式的区别

* **示例:** 句柄: 文件句柄、窗口句柄

| Window                |
| --------------------- |
| DrawText() DrawRect() |

| WindowImp                   |
| --------------------------- |
| DevDrawText() DevDrawLine() |

| IconWindow   |
| ------------ |
| DrawBorder() |

| TransientWindow |
| --------------- |
| DrawCloseBox()  |

| XWindowImp                  |
| --------------------------- |
| DevDrawText() DevDrawLine() |

| PIMWindowImp                |
| --------------------------- |
| DevDrawLine() DevDrawText() |

XDrawLine()\
XDrawString()

# 计数句柄/体模式

Counted Handle/Body

# 模式9: 组合模式 (一)

在绘图编辑器和图形捕捉系统这样的图形应用程序中，用户可以使用简单的图元创建复杂的图表。用户可以组合多个简单图元以形成一些较大的图表，这些图表又可以组合成更大的图表。一个简单的实现方法是为Text和Line这样的图元定义一些类，另外定义一些类作为这些图元的容器类(Container)。

然而这种方法存在一个问题：使用这些类的代码必须区别对待图元对象与容器对象，而实际上大多数情况下用户认为它们是一样的。对这些类区别使用，使得程序更加复杂。

# 模式9: 组合模式 (续)

组合模式描述了如何使用递归组合，使得用户不必对这些类进行区别，如下图所示。

Graphic\
Draw()\
Add(Graphic)\
Remove(Graphic)\
GetChild(int)

Line\
Draw()

Rectangle\
Draw()

Text\
Draw()

Picture\
Draw()\
Add(Graphic g)\
Remove(Graphic)\
GetChild(int)

graphics\
forall g in graphics\
g.Draw()

add g to list of graphics

# 组合模式 (一)

* **意图:**
  * 将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

* **动机:**

  * 一些部件对象经过组合构成的复合部件对象仍然具有单个部件对象的接口，这样的复合部件对象被称为"容器(container)"
  * 复合部件与单个部件具有同样的接口，所有接口包含两部分：单个部件的功能、管理子部件的功能

* 递归组合

# 组合模式 (三)

## 结构

**Client**\
Component\
Operation()\
Add(Component)\
Remove(Component)\
GetChild(int)

**Leaf**\
Operation()

**Composite**\
Operation()\
Add(Component)\
Remove(Component)\
GetChild(int)

### 参与者

Client, Component, Leaf, Composite

# 组合模式 (二)

## 适用性

在以下情况使用组合模式：

* 你想表示对象的部分-整体层次结构
* 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象

# 组合模式 (四)

## 评估

* 定义了包含叶子对象和组合对象的类层次接口。——递归结构
* 使客户端简单。客户一致地处理复合对象和单个对象
* 更容易添加新类型的组件
* 可能使设计过于通用。容易增加新组件也会产生一些问题，那就是很难限制组合中的组件。有时你希望一个组合只能有某些特定的组件。使用组合模式时，你不能依赖类型系统施加这些约束，而必须在运行时刻进行检查

# 组合模式 (五)

## 实现

* **显式父部件引用：** 保持从子部件到父部件的引用能简化组合结构的遍历和管理。父部件引用可以简化结构的上移和组件的删除。通常在Component类中定义父部件引用。Leaf和Composite类可以继承这个引用以及管理这个引用的那些操作
* **最大化Component接口：** 组合模式的目的是使用户不知道他们正在使用的具体的Leaf和Composite类。为了达到这一目的，Composite类应为Leaf和Composite类尽可能多定义一些公共操作。Composite类通常为这些操作提供缺省的实现，而Leaf和Composite子类可以对它们进行重定义

# 组合模式 (五)

## 实现（续）

* **声明子部件管理操作：** 虽然Composite类实现了Add和Remove操作用于管理子部件，但在组合模式中一个重要的问题是：在Composite类层次结构中哪一些类声明这些操作
* 我们是在Component中声明这些操作，并使这些操作对Leaf类有意义呢，还是只应该在Composite和它的子类中声明并定义这些操作呢？

# 组合模式 (五)

## 声明子部件管理操作（续）

这需要在安全性和透明性之间做出权衡选择

* 在类层次结构的根部定义子节点管理接口的方法具有良好的透明性，因为你可以一致地使用所有的组件，但是这一方法是以安全性为代价的，因为客户有可能会做一些无意义的事情，例如在Leaf中增加和删除对象等
* 在Composite类中定义管理子部件的方法具有良好的安全性，因为在象C++这样的静态类型语言中，在编译时任何从Leaf中增加或删除对象的尝试都将被发现。但是这又损失了透明性，因为Leaf和Composite具有不同的接口

在这一模式中，相对于安全性，我们比较强调透明性。如果你选择了安全性，有时你可能会丢失类型信息，并且不得不将一个组件转换成一个组合。这样的类型转换必定不是类型安全的

# 组合模式 (五)

## 声明子部件管理操作（续）

一种办法是在Component类中声明一个操作：

**Composite\* GetComposite()**\
class Component{\
public:\
    //...\
    virtual Composite\* GetComposite(){return 0;}\
    //...\
};

空指针的缺省操作

**Composite类重新定义这个操作并通过this指针返回它自身**

class Composite: public Component{\
public:\
    void Add(Component\*);\
    //...\
    virtual Composite\* GetComposite(){return this;}\
};

class Leaf: public Component{\
    //...\
};

# 组合模式 (五)

## 声明子部件管理操作（续）

GetComposite允许你查询一个组件看它是否是一个组合，你可以对返回的组合安全地执行Add和Remove操作

Composite\* aComposite=new Composite;\
Leaf\* aLeaf = new Leaf;

Component\* aComponent;\
Composite\* test;

aComponent = aComposite;\
if (test = aComponent->GetComposite()){\
    test->Add(new Leaf);\
}

aComponent = aLeaf;\
if (test = aComponent->GetComposite()){\
    test->Add(new Leaf); //不会添加leaf\
}

# 组合模式 (五)

## 子节点排序

* 在许多设计中可能需要指定Composite的子部件顺序。在前面Graphics例子中，排序可能表示了从前至后的顺序。如果Composite表示语法分析树，Composite子部件的顺序必须反映程序结构，而组合语句就是这样一些Composite的实例
* 如果需要考虑子节点的顺序时，必须仔细地设计对子节点的访问和管理接口，以便管理子节点序列。迭代器模式可以在这方面给予一定的指导

# 组合模式 (五)

## 存储组件最好用哪一种数据结构？

组合模式可使用多种数据结构存贮它们的子节点，包括连接列表、树、数组和hash表。数据结构的选择取决于效率

# 模式10: 外观模式 (一)

* **意图:**
  * 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
* **动机:**
  * 使系统的各子系统之间的关联最小，引入一个facade对象，为子系统提供一个简单的、泛化的设施

# 外观模式 (二)

## 适用性

在以下情况使用外观模式：

* 为一个复杂的子系统提供一个简单接口时

  * 子系统往往会非常复杂，但是其接口应该尽可能地简单
  * 特别是对于一般用户而言

* 客户与抽象类的实现部分之间必然存在一定的依赖性
  * 外观可以降低这种依赖性

* 在多个子系统的结构中，使用外观模式定义子系统的入口点，有助于降低各子系统之间的依赖性

# 外观模式 (三)

## 结构

subsystem classes\
Facade

### 参与者

facade, subsystem classes

# 外观模式 (四)

## 评估

* 简化子系统的接口，方便客户使用子系统
* 化"紧耦合"为"松耦合" ——实现组件软件的关键技术
* 外观模式并不限制客户直接访问子系统的内部类和对象

## 实现

* 以抽象类的形式定义外观，进一步解耦，从而完全隔离子系统的细节
* 公共与私有子系统类

# 外观模式 (五)

## 相关模式与示例

* **相关模式:**
  * 外观对象的创建：单例模式、抽象工厂模式
* **示例:** 例如有一个编程环境，它允许应用程序访问它的编译子系统。这个编译子系统包含了若干个类，如Scanner、Parser、ProgramNode、BytecodeStream和ProgramNodeBuilder，用于实现这一编译器。有些特殊应用程序需要直接访问这些类，但是大多数编译器的用户并不关心语法分析和代码生成这样的细节；他们只是希望编译一些代码。对这些用户，编译子系统中那些功能强大但层次较低的接口只会使他们的任务复杂化

# 示例（续）

**Compiler**\
Compile()

编译子系统的类

**Stream**\
BytecodeStream

**CodeGenerator**\
StackMachineCodeGenerator\
RISCCodeGenerator

**Scanner**\
Server\
Token\
Symbol

**ProgramNodeBuilder**\
ProgramNode\
StatementNode\
ExpressionNode\
VariableNode

# 模式11：享元模式 (一)

* **意图:**
  * 运用共享技术有效地支持大量细粒度的对象
* **动机:**
  * 当对象的粒度太小的时候，大量对象将会产生巨大的资源消耗，因此考虑用共享对象(flyweight)来实现逻辑上的大量对象。享元对象可用于不同的context中，本身固有的状态不随context发生变化，而其他的状态随context而变化

# 享元模式 (二)

## 适用性

在以下所有条件都满足时使用享元模式：

* 一个应用程序使用了大量的对象
* 由于对象数量巨大，存储开销很高
* 大多数对象状态可以变为外部状态
* 一旦移除了外部状态，许多对象组可以被相对较少的共享对象替代
* 应用程序不依赖于对象标识。由于享元对象可以被共享，对于概念上不同的对象，标识测试将返回真

# 享元模式 (三)

## 结构

**FlyweightFactory**\
GetFlyweight(key)

if (Flyweight\[key] exist) {\
    return existingFlyweight;\
} else {\
    create new flyweight;\
    add it to pool of flyweights;\
    return the new flyweight;\
}

**Flyweight**\
Operation(extrinsicState)

| ConcreteFlyweight         | UnsharedConcreteFlyweight |
| ------------------------- | ------------------------- |
| Operation(extrinsicState) | Operation(extrinsicState) |
| intrinsicState            | allState                  |

Client

# 享元模式 (四)

## 结构(续)

| aFlyweightFactory | flyweight pool |
| ----------------- | -------------- |
| flyweights        |                |

| aClient | aClient |
| ------- | ------- |
|         |         |

| aConcreteFlyweight | aConcreteFlyweight |
| ------------------ | ------------------ |
| intrinsicState     | intrinsicState     |

### 参与者

client, flyweight, concreteFlyweight, FlyweightFactory, UnsharedConcreteFlyweight

# 享元模式 (五)

## 评估

* 把对象的状态分开：内部状态和外部状态
* 节约存储空间：内部状态的共享节约了大量空间，外部状态可通过计算获得从而进一步节约空间
* 享元模式与组合模式结合。享元为叶子节点，并且父节点只能作为外部状态

## 实现

* 移除外部状态，尽可能做到实时计算(通过一个小的数据结构)
* 管理共享对象，客户不能直接实例化享元，必须通过管理器，例如FlyweightFactory。享元的生命周期管理，引用计数和回收

# 享元模式 (六)

## 相关模式与示例

* **相关模式:**

  * 与组合模式组合
  * 可以用享元实现状态模式和策略模式中的对象

* **示例:**

  * Excel中单元格的管理

    * IOleItemContainer接口允许客户发现每一个单元格对象
    * 用享元实现单元格对象 —— tearoff技术
    * 对状态的有效管理是对象技术的一个进步

  * "Design Patterns"中提到的文档编辑器的例子

# 享元模式 (六)

## 示例

**Glyph**\
Draw(Context)\
Intersects(Point, Context)

**Row**\
Draw(Context)\
Intersects(Point, Context)

**Character**\
Draw(Context)\
Intersects(Point, Context)

**Column**\
Draw(Context)\
Intersects(Point, Context)

children

# 结构型模式：装饰器模式

Component Operation()

**ConcreteComponent**\
Operation()

**Decorator**\
Operation()\
Component->operation();

**ConcreteDecoratorA**\
Operation()\
addedState

**ConcreteDecoratorB**\
Operation()\
addedBehaviour()\
Decorator::Operation();\
AddedBehaviour();

# 结构型模式：代理模式

Client\
Subject Request()

RealSubject request()\
realSubject request()

Proxy Request()\
... realSubject->Request().\
...

aClient subject\
aProxy realSubject\
aRealSubject

# 结构型模式小结

* 适配器、桥接、外观

  * 适配器用于两个不兼容接口之间的转接
  * 桥接用于将一个抽象与多个可能的实现连接起来
  * 外观用于为复杂的子系统定义一个新的简单易用的接口

* 组合、装饰器和代理

  * 组合用于构造对象组合结构
  * 装饰器用于为对象增加新的职责
  * 代理为目标对象提供一个替代者

* 享元
  * 针对细粒度对象的一种全局控制手段
